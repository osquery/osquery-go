// Package table creates an osquery table plugin.
package table

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/osquery/osquery-go/gen/osquery"
	"github.com/osquery/osquery-go/traces"
	"github.com/pkg/errors"
	"go.opentelemetry.io/otel/codes"
)

// Generate returns the rows generated by the table. The ctx argument
// should be checked for cancellation if the generation performs a
// substantial amount of work. The queryContext argument provides the
// deserialized JSON query context from osquery.
type GenerateFunc func(ctx context.Context, queryContext QueryContext) ([]map[string]string, error)

type Plugin struct {
	name     string
	columns  []ColumnDefinition
	generate GenerateFunc
}

func NewPlugin(name string, columns []ColumnDefinition, gen GenerateFunc) *Plugin {
	return &Plugin{
		name:     name,
		columns:  columns,
		generate: gen,
	}
}

func (t *Plugin) Name() string {
	return t.name
}

func (t *Plugin) RegistryName() string {
	return "table"
}

func (t *Plugin) Routes() osquery.ExtensionPluginResponse {
	routes := []map[string]string{}
	for _, col := range t.columns {
		routes = append(routes, map[string]string{
			"id":   "column",
			"name": col.Name,
			"type": string(col.Type),
			"op":   strconv.FormatUint(uint64(col.Options), 10),
		})
	}
	return routes
}

func (t *Plugin) Call(ctx context.Context, request osquery.ExtensionPluginRequest) osquery.ExtensionResponse {
	ctx, span := traces.StartSpan(ctx, t.name, "action", request["action"], "table_name", t.name)
	defer span.End()

	ok := osquery.ExtensionStatus{Code: 0, Message: "OK"}
	switch request["action"] {
	case "generate":
		queryContext, err := parseQueryContext(request["context"])
		if err != nil {
			return osquery.ExtensionResponse{
				Status: &osquery.ExtensionStatus{
					Code:    1,
					Message: "error parsing context JSON: " + err.Error(),
				},
			}
		}

		rows, err := t.generate(ctx, *queryContext)
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			return osquery.ExtensionResponse{
				Status: &osquery.ExtensionStatus{
					Code:    1,
					Message: "error generating table: " + err.Error(),
				},
			}
		}

		return osquery.ExtensionResponse{
			Status:   &ok,
			Response: rows,
		}

	case "columns":
		return osquery.ExtensionResponse{
			Status:   &ok,
			Response: t.Routes(),
		}

	default:
		return osquery.ExtensionResponse{
			Status: &osquery.ExtensionStatus{
				Code:    1,
				Message: "unknown action: " + request["action"],
			},
		}
	}

}

func (t *Plugin) Ping() osquery.ExtensionStatus {
	return osquery.ExtensionStatus{Code: 0, Message: "OK"}
}

func (t *Plugin) Shutdown() {}

// ColumnDefinition defines the relevant information for a column in a table
// plugin. Both values are mandatory. Prefer using the *Column helpers to
// create ColumnDefinition structs.
type ColumnDefinition struct {
	Name        string
	Type        ColumnType
	Options     columnOptions // bitmask
	Description string
}

// NewColumn returns a ColumnDefinition for the specified column. It
// defaults to a TEXT column, and accepts functional args to change
// settings.
func NewColumn(name string, opts ...ColumnOpt) ColumnDefinition {
	cd := ColumnDefinition{
		Name: name,
		Type: ColumnTypeText, // Default to TEXT, and not UNKNOWN
	}

	for _, opt := range opts {
		opt(&cd)
	}

	return cd

}

// ColumnType is a strongly typed representation of the data type string for a
// column definition. The named constants should be used.
type ColumnType string

// The following column types are defined in osquery tables.h and column.cpp
const (
	ColumnTypeUnknown        ColumnType = "UNKNOWN"
	ColumnTypeText                      = "TEXT"
	ColumnTypeInteger                   = "INTEGER"
	ColumnTypeBigInt                    = "BIGINT"
	ColumnTypeUnsignedBigInt            = "UNSIGNED BIGINT"
	ColumnTypeDouble                    = "DOUBLE"
	ColumnTypeBlob                      = "BLOB"
)

// TextColumn is a DEPRECATED helper for defining columns containing strings.
func TextColumn(name string, opts ...ColumnOpt) ColumnDefinition {
	return NewColumn(name, append(opts, IsText())...)
}

// IntegerColumn is a DEPRECATED helper for defining columns containing integers.
func IntegerColumn(name string, opts ...ColumnOpt) ColumnDefinition {
	return NewColumn(name, append(opts, IsInteger())...)
}

// BigIntColumn is a DEPRECATED helper for defining columns containing big integers.
func BigIntColumn(name string, opts ...ColumnOpt) ColumnDefinition {
	return NewColumn(name, append(opts, IsBigInt())...)
}

// DoubleColumn is a DEPRECATED helper for defining columns containing floating point
// values.
func DoubleColumn(name string, opts ...ColumnOpt) ColumnDefinition {
	return NewColumn(name, append(opts, IsDouble())...)
}

// setColumnType is an internal function to set column type
func setColumnType(ctype ColumnType) ColumnOpt {
	return func(cd *ColumnDefinition) {
		cd.Type = ctype
	}
}

// IsUnknown is a functional argument that defines this as an unknown column
func IsUnknown() ColumnOpt { return setColumnType(ColumnTypeUnknown) }

// IsText is a functional argument that defines this as a text column
func IsText() ColumnOpt { return setColumnType(ColumnTypeText) }

// IsInteger is a functional argument that defines this as a text column
func IsInteger() ColumnOpt { return setColumnType(ColumnTypeInteger) }

// IseBigInt is a functional argument that defines this as a text column
func IsBigInt() ColumnOpt { return setColumnType(ColumnTypeBigInt) }

// IsUnsignedBigInt is a functional argument that defines this as a text column
func IsUnsignedBigInt() ColumnOpt { return setColumnType(ColumnTypeUnsignedBigInt) }

// IsDouble is a functional argument that defines this as a text column
func IsDouble() ColumnOpt { return setColumnType(ColumnTypeDouble) }

// IsTypeBlob is a functional argument that defines this as a text column
func IsTypeBlob() ColumnOpt { return setColumnType(ColumnTypeBlob) }

// ColumnOption are the osquery column options. These are represented by a bitmask
type columnOptions uint8

// From https://github.com/osquery/osquery/blob/master/osquery/core/sql/column.h#L37
const (
	columnOptionDefault    columnOptions = 0
	columnOptionIndex                    = 1
	columnOptionRequired                 = 2
	columnOptionAdditional               = 4
	columnOptionOptimized                = 8
	columnOptionHidden                   = 16
)

// setColumnOption is an internal function that applies the column options.
func setColumnOption(flag columnOptions) ColumnOpt {
	return func(cd *ColumnDefinition) {
		cd.Options = cd.Options | flag
	}
}

// IndexColumn is a functional argument to declare this as an indexed
// column. Depending on impmelentation, this can significantly change
// performance.  See osquery source code for more information.
func IndexColumn() ColumnOpt { return setColumnOption(columnOptionIndex) }

// RequiredColumn is a functional argument that sets this as a
// required column. sqlite will not process queries, if a required
// column is missing. See osquery source code for more information.
func RequiredColumn() ColumnOpt { return setColumnOption(columnOptionRequired) }

// AdditionalColumn is a functional argument that sets this as an
// additional column. See osquery source code for more information.
func AdditionalColumn() ColumnOpt { return setColumnOption(columnOptionAdditional) }

// OptimizedColumn is a functional argument that sets this as an
// optimized column. See osquery source code for more information.
func OptimizedColumn() ColumnOpt { return setColumnOption(columnOptionOptimized) }

// HiddenColumn is a functional argument that sets this as an
// hidden column. This omits it from `select *` queries. See osquery source code for more information.
func HiddenColumn() ColumnOpt { return setColumnOption(columnOptionHidden) }

// ColumnDescription sets the column description. This is not
// currently part of the underlying osquery api, it is here for human
// consumption. It may become part of osquery spec generation.
func ColumnDescription(d string) ColumnOpt {
	return func(cd *ColumnDefinition) {
		cd.Description = d
	}
}

type ColumnOpt func(*ColumnDefinition)

// QueryContext contains the constraints from the WHERE clause of the query,
// that can optionally be used to optimize the table generation. Note that the
// osquery SQLite engine will perform the filtering with these constraints, so
// it is not mandatory that they be used in table generation.
type QueryContext struct {
	// Constraints is a map from column name to the details of the
	// constraints on that column.
	Constraints map[string]ConstraintList
}

// ConstraintList contains the details of the constraints for the given column.
type ConstraintList struct {
	Affinity    ColumnType
	Constraints []Constraint
}

// Constraint contains both an operator and an expression that are applied as
// constraints in the query.
type Constraint struct {
	Operator   Operator
	Expression string
}

// Operator is an enum of the osquery operators.
type Operator int

// The following operators are dfined in osquery tables.h.
const (
	OperatorEquals              Operator = 2
	OperatorGreaterThan                  = 4
	OperatorLessThanOrEquals             = 8
	OperatorLessThan                     = 16
	OperatorGreaterThanOrEquals          = 32
	OperatorMatch                        = 64
	OperatorLike                         = 65
	OperatorGlob                         = 66
	OperatorRegexp                       = 67
	OperatorUnique                       = 1
)

// The following types and functions exist for parsing of the queryContext
// JSON and are not made public.
type queryContextJSON struct {
	Constraints []constraintListJSON `json:"constraints"`
}

type constraintListJSON struct {
	Name     string          `json:"name"`
	Affinity string          `json:"affinity"`
	List     json.RawMessage `json:"list"`
}

func parseQueryContext(ctxJSON string) (*QueryContext, error) {
	var parsed queryContextJSON

	err := json.Unmarshal([]byte(ctxJSON), &parsed)
	if err != nil {
		return nil, errors.Wrap(err, "unmarshaling context JSON")
	}

	ctx := QueryContext{map[string]ConstraintList{}}
	for _, cList := range parsed.Constraints {
		constraints, err := parseConstraintList(cList.List)
		if err != nil {
			return nil, err
		}

		ctx.Constraints[cList.Name] = ConstraintList{
			Affinity:    ColumnType(cList.Affinity),
			Constraints: constraints,
		}
	}

	return &ctx, nil
}

func parseConstraintList(constraints json.RawMessage) ([]Constraint, error) {
	var str string
	err := json.Unmarshal(constraints, &str)
	if err == nil {
		// string indicates empty list
		return []Constraint{}, nil
	}

	var cList []map[string]interface{}
	err = json.Unmarshal(constraints, &cList)
	if err != nil {
		// cannot do anything with other types
		return nil, errors.Errorf("unexpected context list: %s", string(constraints))
	}

	cl := []Constraint{}
	for _, c := range cList {
		var op Operator
		switch opVal := c["op"].(type) {
		case string: // osquery < 3.0 with stringy types
			opInt, err := strconv.Atoi(opVal)
			if err != nil {
				return nil, errors.Errorf("parsing operator int: %s", c["op"])
			}
			op = Operator(opInt)
		case float64: // osquery > 3.0 with strong types
			op = Operator(opVal)
		default:
			return nil, errors.Errorf("cannot parse type %T", opVal)
		}

		expr, ok := c["expr"].(string)
		if !ok {
			return nil, errors.Errorf("expr should be string: %s", c["expr"])
		}

		cl = append(cl, Constraint{
			Operator:   op,
			Expression: expr,
		})
	}
	return cl, nil
}
